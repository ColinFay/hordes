[
["index.html", "hordes cookbook hordes cookbook", " hordes cookbook Colin Fay 2020-07-28 hordes cookbook DISCLAIMER - WORK IN PROGRESS: I’m trying to document how to use hordes, but it should take some time… So at the time of reading these lines, a lot of chapters will not be completed. Welcome to hordes cookbook. The first chapter gives a general overview of hordes basics. This chapter is probably the one you should go to if you have no idea what this project is about. The second chapter will introduce you to hordes general philosophy, and about how to think about your code when building tools that make use of hordes. The third chapter introduces the data formats you can use to share things between Node and R in hordes. The fourth chapter develops how to build a full REST API that uses hordes The fifth chapter introduces how to build a full Node web app that can call R functions The sicth chapter shows some benchmark made when it comes to using hordes or other frameworks. "],
["the-whole-game.html", "Chapter 1 The Whole Game 1.1 hordes_init 1.2 library 1.3 mlibrary 1.4 get_hash 1.5 waiter 1.6 Changing the process that runs R", " Chapter 1 The Whole Game This chapter will give you a quick and (I hope) complete overview of what you can do with hordes. This chapter is supposed to be an introduction and won’t go into details on all the functions. Please refer to further chapters if you want to know more! 1.1 hordes_init The library() and mlibrary() functions will be talking to RServe through node-rio. You can either launch Rserve by hand, or from Node by calling hordes_init() at the top of your script if you want to lauch it. You can serve several instances of RServe, by calling hordes_init(port = XXX) where XXX is a port. That also mean that you can open and call several instances of RServe using a Node load balancer. 1.2 library The library function from hordes takes as input an installed R package and returns an object with all the functions from that package as methods. **Note that every function returns a promise, This means that: R fun output should be handled with then/catch or async/await All function will return as an array of strings, unless you specify capture_output = false, then you rely on node-rio to do the conversion. This solution might make things faster if you’re concerned about very high scalability. If you return a data format that is not to be treated as a string (JSON, number…)… you’ll have to transform the data to a JavaScript compatible format. For example, here is how to run a lm from Node. // Here, we suppose you already have Rserve running in the background on port 6311 const {library} = require(&#39;hordes&#39;); const stats = library(package = &quot;stats&quot;); stats.lm(&quot;Sepal.Length ~ Sepal.Width, data = iris&quot;) .then((e) =&gt; console.log(e.join(&quot;\\n&quot;))) .catch((err) =&gt; console.error(err)) Will output to the console: Call: stats::lm(formula = Sepal.Length ~ Sepal.Width, data = iris) Coefficients: (Intercept) Sepal.Width 6.5262 -0.2234 The rest of this guide will use async/await const { library } = require(&#39;hordes&#39;); const stats = library(&quot;stats&quot;); (async() =&gt; { // Launching RServe from Node await hordes_init(); try { const a = await stats.lm(&quot;Sepal.Length ~ Sepal.Width, data = iris&quot;) console.log(a) } catch (e) { console.log(e) } try { const a = stats.lm(&quot;Sepal.Length ~ Sepal.Width, data = iris&quot;) const b = stats.lm(&quot;Sepal.Length ~ Petal.Width, data = iris&quot;) const ab = await Promise.all([a, b]) console.log(ab[0]) console.log(ab[1]) } catch (e) { console.log(e) } })(); Call: stats::lm(formula = Sepal.Length ~ Sepal.Width, data = iris) Coefficients: (Intercept) Sepal.Width 6.5262 -0.2234 Call: stats::lm(formula = Sepal.Length ~ Sepal.Width, data = iris) Coefficients: (Intercept) Sepal.Width 6.5262 -0.2234 Call: stats::lm(formula = Sepal.Length ~ Petal.Width, data = iris) Coefficients: (Intercept) Petal.Width 4.7776 0.8886 1.3 mlibrary mlibrary does the same job as library except the functions are natively memoized. Unless your data are changing between each function call, this is probably the mode you’d want to chose. // Here, we suppose you already have Rserve running in the background on port 6311 const {library, mlibrary} = require(&#39;hordes&#39;); const base = library(&quot;base&quot;); const mbase = mlibrary(&quot;base&quot;); (async () =&gt; { try { const a = await base.sample(&quot;1:100, 5&quot;) console.log(&quot;a:&quot;, a) const b = await base.sample(&quot;1:100, 5&quot;) console.log(&quot;b:&quot;, b) } catch(e){ console.log(e) } try { const a = await mbase.sample(&quot;1:100, 5&quot;) console.log(&quot;a:&quot;, a) const b = await mbase.sample(&quot;1:100, 5&quot;) console.log(&quot;b:&quot;, b) } catch(e){ console.log(e) } } )(); a: [1] 49 13 37 25 91 b: [1] 5 17 68 26 29 a: [1] 96 17 6 4 75 b: [1] 96 17 6 4 75 1.4 get_hash When calling library() or mlibrary(), you can specify a hash, which can be compiled with get_hash. This hash is computed from the DESCRIPTION of the package called. That way, if ever the DESCRIPTION file changes (version update, or stuff like that…), you can get alerted (app won’t launch). Just ignore this param if you don’t care about that (but you should in a production setting). const { library, get_hash } = require(&#39;hordes&#39;); console.log(get_hash(&quot;golem&quot;)) &#39;fdfe0166629045e6ae8f7ada9d9ca821742e8135efec62bc2226cf0811f44ef3&#39; Then if you call library() with another hash, the app will fail. var golem = library(&quot;golem&quot;, hash = &quot;blabla&quot;) throw new Error(&quot;Hash from DESCRIPTION doesn&#39;t match specified hash.&quot;) var golem = library(&quot;golem&quot;, hash = &#39;e2167f289a708b2cd3b774dd9d041b9e4b6d75584b9421185eb8d80ca8af4d8a&#39;) Object.keys(golem).length 104 1.5 waiter You can launch an R process that streams data and wait for a specific output in the stdout. The specificity of waiter is that it doesn’t rely on node-rio, but spawn a real R process, and reads the elements streamed on stdout. The promise resolves with and {proc, raw_output}: proc is the process object created by Node, raw_output is the output buffer, that can be turned to string with .toString(). A streaming process here is considered in a lose sense: what we mean here is anything that prints various elements to the console. For example, when you create a new application using the {golem} package, the app is ready once this last line is printed to the console. This is exactly what waiter does, it waits for this last line to be printed to the R stdout before resolving. &gt; golem::create_golem(&#39;pouet&#39;) -- Checking package name ------------------------------------------------------- v Valid package name -- Creating dir ---------------------------------------------------------------- v Created package directory -- Copying package skeleton ---------------------------------------------------- v Copied app skeleton -- Setting the default config -------------------------------------------------- v Configured app -- Done ------------------------------------------------------------------------ A new golem named pouet was created at /private/tmp/pouet . To continue working on your app, start editing the 01_start.R file. const { waiter } = require(&quot;hordes&quot;) const express = require(&#39;express&#39;); const app = express(); app.get(&#39;/creategolem&#39;, async(req, res) =&gt; { try { await waiter(&quot;golem::create_golem(&#39;pouet&#39;)&quot;, {solve_on: &quot;To continue working on your app&quot;}); res.send(&quot;Created &quot;) } catch (e) { console.log(e) res.status(500).send(&quot;Error creating the golem project&quot;) } }) app.listen(2811, function() { console.log(&#39;Example app listening on port 2811!&#39;) }) -&gt; http://localhost:2811/creategolem 1.6 Changing the process that runs R By default, the R code is launched by RScript, but you can specify another (for example if you need another version of R): const { waiter } = require(&quot;hordes&quot;) const express = require(&#39;express&#39;); const app = express(); app.get(&#39;/creategolem&#39;, async(req, res) =&gt; { try { await waiter(&quot;golem::create_golem(&#39;pouet&#39;)&quot;, {solve_on: &quot;To continue working on your app&quot;, process: &#39;/usr/local/bin/RScript&#39;}); res.send(&quot;Created &quot;) } catch (e) { console.log(e) res.status(500).send(&quot;Error creating the golem project&quot;) } }) app.listen(2811, function() { console.log(&#39;Example app listening on port 2811!&#39;) }) "],
["intro.html", "Chapter 2 hordes philosophy 2.1 General Philosophy 2.2 R, package, and stateless code 2.3 General infrastructure consideration", " Chapter 2 hordes philosophy 2.1 General Philosophy The general idea of hordes is that NodeJS is the perfect tool when it comes to HTTP i/o, hence we can leverage the strength of this ecosystem to build Web Services that can serve R results. For example, if you have a web service that needs authentication, using hordes allows to reuse existing NodeJS modules, which are widely used and tested inside the NodeJS ecosystem. Another good example is NodeJS native cluster mode, and external modules like pm2 which are designed to launch your app in a multicore mode, and also that watches that your app is still running continuously, and relaunches it if one of the process stop (kind of handy for a production application that handle a lot of load). It also makes things easier when it comes to mixing various languages in the same API: for example, you can serve standard html on an endpoint, and R on others. And don’t get me started on scaling NodeJS applications. 2.2 R, package, and stateless code From the R point of view, the general idea with hordes is that every R function call should be stateless. Keeping this idea in mind, you can build a package where functions are to be considered as ‘endpoints’ which are then called from NodeJS. In other words, there is no “shared-state” between two calls to R—if you want this to happen, you should either register the values inside Node, save it on disk, or use a database as a backend (which should be the preferred solution if you ask me). 2.3 General infrastructure consideration // TODO "],
["data-exchange.html", "Chapter 3 Data Exchange 3.1 The hordes R package 3.2 JSON 3.3 Text 3.4 Base64 images 3.5 Files &amp; Paths 3.6 Arrow 3.7 Stream", " Chapter 3 Data Exchange If you want to exchange data between R and NodeJS, use an interchangeable format (JSON, arrow, base64 for images, raw strings…). 3.1 The hordes R package There is a hordes R package that contains some functions to facilitate the data translation. It can be installed with remotes::install_github(&quot;colinfay/hordes&quot;, subdir = &quot;r-hordes&quot;) 3.2 JSON Return const {library} = require(&#39;hordes&#39;); const jsonlite = library(&quot;jsonlite&quot;); const base = library(&quot;base&quot;); (async () =&gt; { try { const a = await jsonlite.toJSON(&quot;iris&quot;) console.log(JSON.parse(a)[0]) } catch(e){ console.log(e) } } )(); { &#39;Sepal.Length&#39;: 5.1, &#39;Sepal.Width&#39;: 3.5, &#39;Petal.Length&#39;: 1.4, &#39;Petal.Width&#39;: 0.2, Species: &#39;setosa&#39; } 3.3 Text By default, everything is returned as an array of string. From the R side, it’s better to print things with cat, as it allows to avoid the [1] in front of the console printing. 21 ## [1] 21 (async () =&gt; { try { const b = await base.cat(&quot;21&quot;) console.log(parseInt(b) * 2) } catch(e){ console.log(e) } } )(); 3.4 Base64 images Given the following R function, contained in a package called {hordesx} ggpoint &lt;- function(n) { gg &lt;- ggplot(iris[1:n, ], aes(Sepal.Length, Sepal.Width)) + geom_point() hordes::base64_img_ggplot(gg) } const express = require(&#39;express&#39;); const {library} = require(&#39;hordes&#39;); const app = express(); const hordesx = library(&quot;hordesx&quot;) app.get(&#39;/ggplot&#39;, async (req, res) =&gt; { try { const im = await hordesx.ggpoint(`n = ${req.query.n}`); const img = Buffer.from(im, &#39;base64&#39;); res.writeHead(200, { &#39;Content-Type&#39;: &#39;image/png&#39;, &#39;Content-Length&#39;: img.length }); res.end(img); } catch(e){ res.status(500).send(e) } }) app.listen(2811, function () { console.log(&#39;Example app listening on port 2811!&#39;) }) http://localhost:2811/ggplot?n=5 http://localhost:2811/ggplot?n=50 http://localhost:2811/ggplot?n=150 3.5 Files &amp; Paths // TODO 3.6 Arrow // TODO 3.7 Stream // TODO "],
["building-a-rest-api.html", "Chapter 4 Building a REST API 4.1 REST API 101 4.2 REST API Design pattern with hordes", " Chapter 4 Building a REST API 4.1 REST API 101 4.1.1 About express 4.1.2 Example const express = require(&#39;express&#39;); const {library} = require(&#39;hordes&#39;); const app = express(); const stats = library(&quot;stats&quot;); app.get(&#39;/iris&#39;, async (req, res) =&gt; { try { const output = await jsonlite.toJSON(&quot;iris&quot;) res.send( output ) } catch(e){ res.status(500).send(e) } }) app.get(&#39;/mtcars&#39;, async (req, res) =&gt; { try { const output = await jsonlite.toJSON(&quot;mtcars&quot;) res.send( output ) } catch(e) { res.status(500).send(e) } }) app.listen(2811, function () { console.log(&#39;Example app listening on port 2811!&#39;) }) 4.2 REST API Design pattern with hordes 4.2.1 R package // TODO 4.2.2 Infrastructure // TODO 4.2.3 Example // TODO "],
["building-a-web-app.html", "Chapter 5 Building a Web App 5.1 Example", " Chapter 5 Building a Web App 5.1 Example 5.1.1 Using a Websocket Front End &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; Hello hordes! &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;input type=&quot;range&quot; id=&quot;volume&quot; name=&quot;npoint&quot; min=&quot;0&quot; max=&quot;150&quot; onchange=&quot;update(this.value)&quot;&gt; &lt;label for=&quot;npoint&quot;&gt;n points&lt;/label&gt; &lt;/div&gt; &lt;img id = &quot;plot&quot; src = &quot;/ggplot?n=50&quot; width = &quot;500px&quot;&gt; &lt;img id = &quot;plot2&quot; src = &quot;/ggplot?n=50&quot; width = &quot;500px&quot;&gt; &lt;img id = &quot;plot3&quot; src = &quot;/ggplot?n=50&quot; width = &quot;500px&quot;&gt; &lt;/div&gt; &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var socket = io(); $(function () { var socket = io(); socket.on(&#39;plotbck&#39;, function(base64){ document.getElementById(&quot;plot&quot;).src = `data:image/png;base64, ${base64}` document.getElementById(&quot;plot2&quot;).src = `data:image/png;base64, ${base64}` document.getElementById(&quot;plot3&quot;).src = `data:image/png;base64, ${base64}` }); }); function update(value){ socket.emit(&#39;plot&#39;, value); return false; } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Backend const express = require(&#39;express&#39;); const {library} = require(&#39;hordes&#39;); const app = express(); const http = require(&#39;http&#39;).createServer(app); const io = require(&#39;socket.io&#39;)(http); const hordesx = library(&quot;hordesx&quot;); app.get(&#39;/test&#39;, function(req, res) { res.sendFile(&#39;test.html&#39;, {root: __dirname }) }); io.on(&#39;connection&#39;, async (socket) =&gt; { // Render the first image const image = await hordesx.ggpoint(&#39;n = 50&#39;); io.emit(&#39;plotbck&#39;, image); // Render plot on change socket.on(&#39;plot&#39;, async(value) =&gt; { const image = await hordesx.ggpoint(`n = ${value}`); io.emit(&#39;plotbck&#39;, image); }); }); http.listen(2811, function () { console.log(&#39;Example app listening on port 2811!&#39;) }) R Function #&#39; ggpoint #&#39; #&#39; @export #&#39; @import ggplot2 ggpoint &lt;- function(n) { gg &lt;- ggplot(iris[1:n, ], aes(Sepal.Length, Sepal.Width)) + geom_point() hordes::base64_img_ggplot(gg) } 5.1.2 Using HTTP request (slower) Front end &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; Hello hordes! &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;input type=&quot;range&quot; id=&quot;volume&quot; name=&quot;npoint&quot; min=&quot;0&quot; max=&quot;150&quot; onchange=&quot;change(this.value)&quot;&gt; &lt;label for=&quot;npoint&quot;&gt;n points&lt;/label&gt; &lt;/div&gt; &lt;img id = &quot;plot&quot; src = &quot;/ggplot?n=50&quot; width = &quot;500px&quot;&gt; &lt;img id = &quot;plot2&quot; src = &quot;/ggplot?n=50&quot; width = &quot;500px&quot;&gt; &lt;img id = &quot;plot3&quot; src = &quot;/ggplot?n=50&quot; width = &quot;500px&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function change(value){ document.getElementById(&quot;plot&quot;).src = `/ggplot?n=${value}` document.getElementById(&quot;plot2&quot;).src = `/ggplot?n=${value}` document.getElementById(&quot;plot3&quot;).src = `/ggplot?n=${value}` } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Backend const express = require(&#39;express&#39;); const {library} = require(&#39;hordes&#39;); const app = express(); const hordesx = library(&quot;hordesx&quot;) app.get(&#39;/ggplot&#39;, async (req, res) =&gt; { try { const im = await hordesx.ggpoint(`n = ${req.query.n}`); const img = Buffer.from(im, &#39;base64&#39;); res.writeHead(200, { &#39;Content-Type&#39;: &#39;image/png&#39;, &#39;Content-Length&#39;: img.length }); res.end(img); } catch(e){ res.status(500).send(e) } }) app.get(&#39;/test&#39;, function(req, res) { res.sendFile(&#39;test.html&#39;, {root: __dirname }) }); app.listen(2811, function () { console.log(&#39;Example app listening on port 2811!&#39;) }) R Function #&#39; ggpoint #&#39; #&#39; @export #&#39; @import ggplot2 ggpoint &lt;- function(n) { gg &lt;- ggplot(iris[1:n, ], aes(Sepal.Length, Sepal.Width)) + geom_point() hordes::base64_img_ggplot(gg) } "],
["benchmark.html", "Chapter 6 Benchmark", " Chapter 6 Benchmark // TODO "],
["references.html", "References", " References "]
]
